Various Pseudo code for various systems

// Action Model
{
  id: "string",              // Unique identifier
  name: "string",            // Display name
  description: "string",     // What the action does
  isRestAction: false,       // Is this a rest action?
  
  // Requirements
  requiredClass: "string",   // Required class (or null if any class can do it)
  requiredSkills: [],        // Array of required skills with minimum levels
  requiredFurniture: [],     // Array of required furniture
  
  // Costs and Duration
  statPoolCosts: {},         // Object mapping stat pool IDs to costs
  currencyCosts: {},         // Object mapping currency IDs to costs
  baseDuration: 2000,        // Duration in ms (at 10 ticks/second)
  
  // Rewards
  currencyRewards: {},       // Object mapping currency IDs to rewards
  skillExperience: {},       // Object mapping skill IDs to exp gained
  statPoolRestoration: {},   // Object mapping stat pool IDs to restoration
  
  // Tracking
  completionCount: 0,        // How many times this action has been completed
  totalTimeSpent: 0,         // Total time spent on this action (ms)
  
  // Progress Persistence
  currentProgress: 0,        // Current progress (0-1)
  lastActionStartTime: null  // When the current action instance started
}

// Action Controller (pseudocode)
class ActionController {
  // ... other methods
  
  startAction(actionId) {
    // Set as current action
    this.currentAction = actionId;
    
    // If we have saved progress, restore it
    if (this.actions[actionId].currentProgress > 0) {
      // Resume from saved point
    } else {
      // Start fresh
      this.actions[actionId].currentProgress = 0;
      this.actions[actionId].lastActionStartTime = Date.now();
    }
  }
  
  processAction(deltaTime) {
    // If no current action, do nothing
    if (!this.currentAction) return;
    
    const action = this.actions[this.currentAction];
    
    // Check if we have enough resources
    if (!this.hasEnoughResources(action)) {
      // Switch to rest action
      this.switchToRestAction();
      return;
    }
    
    // Update progress
    action.currentProgress += deltaTime / action.baseDuration;
    
    // If action is complete
    if (action.currentProgress >= 1) {
      // Apply rewards
      this.applyActionRewards(action);
      
      // Track completion
      action.completionCount++;
      action.totalTimeSpent += action.baseDuration;
      
      // Add to log
      this.gameState.actionLog.add(action);
      
      // Reset progress for next iteration
      action.currentProgress = 0;
      action.lastActionStartTime = Date.now();
    }
  }
  
  switchToRestAction() {
    // Store the current action to return to later
    this.previousAction = this.currentAction;
    
    // Switch to default rest action
    this.currentAction = this.defaultRestAction;
  }
  
  checkRestActionCompletion() {
    // If current action is rest and stat pools are full
    if (this.isRestAction(this.currentAction) && this.areStatPoolsFull()) {
      // Return to previous action
      if (this.previousAction) {
        this.currentAction = this.previousAction;
      }
    }
  }
  
  // Check if completion count unlocks improvements
  checkActionImprovements(actionId) {
    const action = this.actions[actionId];
    
    // Check various thresholds
    if (action.completionCount >= 10) {
      // Maybe reduce duration by 5%
    }
    
    if (action.completionCount >= 50) {
      // Maybe increase rewards by 10%
    }
    
    // etc.
  }
}

// Save System (pseudocode)
class SaveSystem {
    saveGame() {
      const saveData = {
        character: this.gameState.character,
        statPools: this.gameState.statPools,
        currencies: this.gameState.currencies,
        skills: this.gameState.skills,
        home: this.gameState.home,
        
        // Action state
        currentAction: this.gameState.currentAction,
        previousAction: this.gameState.previousAction,
        actions: {}, // Only save tracking data, not full action definitions
        
        // Timestamp for offline progress
        timestamp: Date.now()
      };
      
      // Save action tracking data
      for (const actionId in this.gameState.actions) {
        saveData.actions[actionId] = {
          completionCount: this.gameState.actions[actionId].completionCount,
          currentProgress: this.gameState.actions[actionId].currentProgress,
          totalTimeSpent: this.gameState.actions[actionId].totalTimeSpent,
          lastActionStartTime: this.gameState.actions[actionId].lastActionStartTime
        };
      }
      
      localStorage.setItem('gameSave', JSON.stringify(saveData));
    }
    
    loadGame() {
      const saveData = JSON.parse(localStorage.getItem('gameSave'));
      if (!saveData) return false;
      
      // Restore game state
      this.gameState.character = saveData.character;
      this.gameState.statPools = saveData.statPools;
      this.gameState.currencies = saveData.currencies;
      this.gameState.skills = saveData.skills;
      this.gameState.home = saveData.home;
      
      // Restore action state
      this.gameState.currentAction = saveData.currentAction;
      this.gameState.previousAction = saveData.previousAction;
      
      // Restore action tracking data
      for (const actionId in saveData.actions) {
        if (this.gameState.actions[actionId]) {
          this.gameState.actions[actionId].completionCount = saveData.actions[actionId].completionCount;
          this.gameState.actions[actionId].currentProgress = saveData.actions[actionId].currentProgress;
          this.gameState.actions[actionId].totalTimeSpent = saveData.actions[actionId].totalTimeSpent;
          this.gameState.actions[actionId].lastActionStartTime = saveData.actions[actionId].lastActionStartTime;
        }
      }
      
      // Handle offline progress
      this.processOfflineProgress(Date.now() - saveData.timestamp);
      
      return true;
    }
    
    processOfflineProgress(elapsedTime) {
      // Calculate resources generated while offline
      // Progress current action
      // etc.
    }
  }